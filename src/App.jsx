// src/App.jsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import Player from "./components/Player";
import Controls from "./components/Controls";
import { createDeck, shuffleDeck } from "./utils/deck";
import { runDrawRound } from "./gameLogic/drawRound";
import { runShowdown } from "./gameLogic/showdown";
import { evaluateBadugi } from "./utils/badugi";
import {
  alivePlayers,
  nextAliveFrom,
  maxBetThisRound,
  settleStreetToPots,
  isBetRoundComplete,
} from "./gameLogic/roundFlow";

// Â±•Ê≠¥‰øùÂ≠òAPI
import {
  saveRLHandHistory,
  getAllRLHandHistories,
  exportRLHistoryAsJSONL,
} from "./utils/history_rl";

import { useNavigate } from "react-router-dom";


export default function App() {
  const navigate = useNavigate();
  /* --- constants --- */
  const NUM_PLAYERS = 6;
  const SB = 10;
  const BB = 20;
  const betSize = BB;
  const MAX_DRAWS = 3; // DRAW„ÅØ3ÂõûÔºà= DRAW1,2,3Ôºâ

  /* --- states --- */
  const [players, setPlayers] = useState([]);
  const [deck, setDeck] = useState([]);
  const [dealerIdx, setDealerIdx] = useState(0);

  const [phase, setPhase] = useState("BET"); // BET / DRAW / SHOWDOWN

  // Êñ∞Ë¶èËøΩÂä†ÔºöBET„É©„Ç¶„É≥„ÉâÈñãÂßãÊôÇ„ÅÆÂÖàÈ†≠„Éó„É¨„Ç§„É§„Éº„Çí‰øùÊåÅ
  const [drawRound, setDrawRound] = useState(0); // ÂÆå‰∫Ü„Åó„ÅüDRAWÊï∞ 0..3
  // states
  const [raisePerRound, setRaisePerRound] = useState([0, 0, 0, 0]); // ÂêÑBET„É©„Ç¶„É≥„Éâ„ÅÆÂêàË®àRaiseÂõûÊï∞
  const [raisePerSeatRound, setRaisePerSeatRound] = useState(
    () => Array(NUM_PLAYERS).fill(0).map(() => [0, 0, 0, 0]) // [seat][round]
  );
  // === Êñ∞Ë¶è: Ë°åÂãï„É≠„Ç∞ÔºàAIÂ≠¶ÁøíÁî®Ôºâ ===
  const [actionLog, setActionLog] = useState([]);

  // ‰æøÂà©„Éò„É´„Éë„ÉºÔºö‰ªä„Åå„Å©„ÅÆBET„É©„Ç¶„É≥„Éâ„ÅãÔºà0=„Éó„É™, 1=1ÂõûÁõÆÂæå, 2=2ÂõûÁõÆÂæå, 3=3ÂõûÁõÆÂæåÔºâ
  function currentBetRoundIndex() {
    // drawRound=0 „ÅÆÈñì„ÅØ„Éó„É™„Éâ„É≠„ÉºBET‰∏≠„Å™„ÅÆ„Åß 0„ÄÅ
    // ‰ª•Èôç„ÅØ drawRound „Å®Âêå„ÅòÁï™Âè∑ÔºàÊúÄÂ§ß3Ôºâ„ÅßOK
    return Math.min(drawRound, 3);
  }

  
  const [pots, setPots] = useState([]);

  const [turn, setTurn] = useState(0);
  const [currentBet, setCurrentBet] = useState(0);

    // ÂêÑBET„É©„Ç¶„É≥„Éâ„ÅÆRaiseÂõûÊï∞„ÇíË®òÈå≤
  const [raiseCountThisRound, setRaiseCountThisRound] = useState(0);


  // ÂÜçÂÖ•Èò≤Ê≠¢Ôºö„É©„Ç¶„É≥„ÉâÈÅ∑Áßª„ÇÑNPCÂá¶ÁêÜ„Åå‰∫åÈáçÁô∫ÁÅ´„Åó„Å¶„Åä„Åã„Åó„Åè„Å™„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´
  const [transitioning, setTransitioning] = useState(false);
  const [betHead, setBetHead] = useState(null);
  const [showNextButton, setShowNextButton] = useState(false);

  // ‚ñº ËøΩË®òÔºö„Åì„ÅÆ„Éè„É≥„Éâ„Çí‰øùÂ≠òÊ∏à„Åø„Åã„Å©„ÅÜ„ÅãÔºàÂ§öÈáç‰øùÂ≠òÈò≤Ê≠¢Ôºâ
  const handSavedRef = useRef(false);
  // ‰æøÂÆú‰∏ä„ÅÆ handIdÔºà„Éá„Ç£„Éº„É©„ÉºÂ∫ßÂ∏≠Ôºã„Çø„Ç§„É†„Çπ„Çø„É≥„ÉóÔºâ
  const handIdRef = useRef(null);

  // ‚ñº „Éá„Éê„ÉÉ„Ç∞„Éà„Ç∞„É´ËøΩÂä†
  const [debugMode, setDebugMode] = useState(false);
  function debugLog(...args) {
    if (debugMode) console.log(...args);
  }
  
  // ======== DEBUG LOGGER (add just under debugLog) ========
const actionSeqRef = useRef(0); // ÈÄ£Áï™

function betRoundNo() {
  // BET „ÅÆÂõûÊï∞„ÅØ„ÄåÂÆå‰∫Ü„Åó„Åü DRAW Êï∞„Äç„Å´‰∏ÄËá¥Ôºà0..3Ôºâ
  return Math.min(drawRound, MAX_DRAWS);
}
function drawRoundNo() {
  // Ë°®Á§∫Áî®Ôºà1..3Ôºâ
  return Math.min(drawRound + 1, MAX_DRAWS);
}
function phaseTagLocal() {
  if (phase === "BET")  return `BET#${betRoundNo()}`;
  if (phase === "DRAW") return `DRAW#${drawRound + 1}`;
  return "SHOWDOWN";
}

function logState(tag, snap = players) {
  if (!debugMode) return;
  const head = `[${phaseTagLocal()}] ${tag} (turn=${turn}, betHead=${betHead}, currentBet=${currentBet})`;
  console.groupCollapsed(head);
  try {
    console.table(
      snap.map((p, i) => ({
        i,
        name: p.name,
        act: p.lastAction || "",
        folded: p.folded ? "‚úì" : "",
        allIn: p.allIn ? "‚úì" : "",
        stack: p.stack,
        betThisRound: p.betThisRound,
        drawn: p.hasDrawn ? "‚úì" : "",
      }))
    );
    console.log("pots:", pots, "totalPot:", totalPotForDisplay);
  } finally {
    console.groupEnd();
  }
}

function logAction(i, type, payload = {}) {
  if (!debugMode) return;
  const seq = ++actionSeqRef.current;
  const nm = players[i]?.name ?? `P${i}`;
  console.log(`[${phaseTagLocal()}][#${seq}] ${nm} ${type}`, payload);
}

// === Êñ∞Ë¶è: Ë°åÂãïË®òÈå≤„ÇíAIÂ≠¶ÁøíÁî®„É≠„Ç∞„Å´‰øùÂ≠ò ===
function recordActionToLog({ round, seat, type, stackBefore, betAfter, raiseCountTable }) {
  setActionLog(prev => [
    ...prev,
    {
      round,
      seat,
      type,
      stackBefore,
      betAfter,
      raiseCountTable,
      ts: Date.now(),
    }
  ]);
}

  /* --- utils --- */
  function makeEmptyPlayers() {
    const names = ["You", "P2", "P3", "P4", "P5", "P6"];
    return Array.from({ length: NUM_PLAYERS }, (_, i) => ({
      name: names[i] ?? `P${i + 1}`,
      hand: [],
      folded: false,
      allIn: false,
      stack: 1000,
      betThisRound: 0,
      selected: [],
      showHand: false,
      lastAction: "",
      hasDrawn: false,
      lastDrawCount: 0,
    }));
  }

  const totalPotForDisplay = useMemo(() => {
    const settled = pots.reduce((acc, p) => acc + (p.amount || 0), 0);
    const onStreet = players.reduce((acc, p) => acc + (p.betThisRound || 0), 0);
    return settled + onStreet;
  }, [pots, players]);

  /* --- phase helpers --- */
  function goShowdownNow(playersSnap) {
    const { pots: newPots } = settleStreetToPots(playersSnap, pots);
    setPots(newPots);
    setPlayers(playersSnap.map((p) => ({ ...p, showHand: !p.folded })));
    setPhase("SHOWDOWN");

    setTimeout(
      () =>
        runShowdown({
          players: playersSnap,
          setPlayers,
          pots: newPots,
          setPots,
          dealerIdx,
          dealNewHand,
          setShowNextButton,
        }),
      200
    );
  }

  function getNextAliveAfter(idx) {
    if (!players || players.length === 0) return null;
    const n = players.length;
    let next = (idx + 1) % n;
    let safety = 0;
    while (players[next]?.folded) {
      next = (next + 1) % n;
      safety++;
      if (safety > n) return null; // ÂÖ®Âì°„Éï„Ç©„Éº„É´„ÉâÁ≠â„ÅÆ‰øùÈô∫
    }
    return next;
  }

  function checkIfOneLeftThenEnd() {
    if (!players || players.length === 0) return false;

    const active = players.filter((p) => !p.folded);
    if (active.length === 1) {
      const winnerIdx = players.findIndex((p) => !p.folded);
      const newPlayers = [...players];
      const potSum = totalPotForDisplay;
      newPlayers[winnerIdx] = {
        ...newPlayers[winnerIdx],
        stack: newPlayers[winnerIdx].stack + potSum,
      };
      setPlayers(newPlayers);

      // „Éè„É≥„Éâ‰øùÂ≠òÔºà„Éï„Ç©„Éº„É´„ÉâÂãù„Å°„ÅÆÊó©ÊúüÁµÇ‰∫ÜÔºâ
      trySaveHandOnce({
        playersSnap: newPlayers,
        dealerIdx,
        pots,
        potOverride: potSum,
      });

      const nextDealer = (dealerIdx + 1) % NUM_PLAYERS;
      setTimeout(() => dealNewHand(nextDealer), 600);
      return true;
    }
    return false;
  }

function finishBetRoundFrom(playersSnap) {
  debugLog("[BET] Round complete ‚Üí finishBetRoundFrom, drawRound(current)=", drawRound);

  // ÁèæÂú®„ÅÆ„Çπ„Éà„É™„Éº„Éà„ÇíÊ∏ÖÁÆó
  logState("BET round complete ‚Üí settle", playersSnap);
  const { pots: newPots, clearedPlayers } = settleStreetToPots(playersSnap, pots);
  const reset = clearedPlayers.map((p) => ({
    ...p,
    hasDrawn: false,
    lastDrawCount: 0,
  }));

  setPots(newPots);
  setPlayers(reset);

  // --- DRAW„Å∏ÈÄ≤Ë°å ---
   if (drawRound < MAX_DRAWS) {
     const nextRound = drawRound + 1;
     setDrawRound(nextRound); // ‚Üê „Åì„Åì„ÅßÂ¢óÂä†
     setPhase("DRAW"); // ‚Üê phaseÊõ¥Êñ∞„ÇíÂêåÊúü
     setCurrentBet(0);
     setBetHead(null);
     setTurn((dealerIdx + 1) % NUM_PLAYERS);
     debugLog(`[FLOW] ‚Üí DRAW #${nextRound} start`);
     setTimeout(() => logState(`‚Üí ENTER DRAW#${nextRound}`, reset), 0);
     return;
  }

  // ‚úÖ ÂÖ®„Éâ„É≠„ÉºÂÆå‰∫Ü ‚Üí SHOWDOWN
  setTimeout(() => logState("‚Üí ENTER SHOWDOWN", reset), 0);
  setPhase("SHOWDOWN");
  setTimeout(() => {
    runShowdown({
      players: playersSnap,
      setPlayers,
      pots: newPots,
      setPots,
      dealerIdx,
      dealNewHand,
      setShowNextButton,
    });
  }, 200);
  debugLog("[BET] All draws done ‚Üí SHOWDOWN");
}



  function advanceAfterAction(updatedPlayers) {
  debugLog("[FLOW] advanceAfterAction called");
  const snap = updatedPlayers || players;
  debugLog("[FLOW] phase:", phase, "drawRound:", drawRound);

  // ÂãùË≤†Ê±∫„Åæ„Å£„Å¶„Åü„ÇâÁµÇ‰∫Ü
  if (checkIfOneLeftThenEnd()) return;

  // ------------------------
  // BET„Éï„Çß„Éº„Ç∫‰∏≠„ÅÆÈÄ≤Ë°å
  // ------------------------
  if (phase === "BET") {
    const next = getNextAliveAfter(turn);
    if (next === null) return;

    const active = snap.filter((p) => !p.folded);
    const everyoneMatched = active.every((p) => p.betThisRound === currentBet);

    // üí° ÂÖ®Âì°„Éû„ÉÉ„ÉÅ„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà ‚Üí BETÁµÇ‰∫Ü
   if (everyoneMatched) {
    debugLog("[BET] ‚úÖ Everyone matched ‚Üí finishBetRoundFrom()");
    setTransitioning(true);
    setTimeout(() => {
      finishBetRoundFrom(snap);
      setTransitioning(false);
    }, 100);
    return;
  }

  // „Åù„Çå‰ª•Â§ñ ‚Üí Ê¨°„Éó„É¨„Ç§„É§„Éº„Å∏
  setTurn(next);
  return;
  }

  // ------------------------
  // DRAW„Éï„Çß„Éº„Ç∫‰∏≠„ÅÆÈÄ≤Ë°å
  // ------------------------
  if (phase === "DRAW") {
   debugLog("[DRAW] Checking if allActiveDrawn...");
 
   const activePlayers = snap.filter((p) => !p.folded && !p.allIn);
   const allActiveDrawn = activePlayers.every((p) => p.hasDrawn);

   if (allActiveDrawn) {
      // ‚úÖ ‰∫åÈáçÂëº„Å≥Âá∫„ÅóÈò≤Ê≠¢
      if (!transitioning) {
        setTransitioning(true);
        debugLog("[DRAW] ‚úÖ allActiveDrawn ‚Üí finishDrawRound()");
        setTimeout(() => {
          finishDrawRound();
          setTransitioning(false);
        }, 200);
      }
      return;
    }

    // Ê¨°„ÅÆÊú™„Éâ„É≠„ÉºËÄÖ„ÇíÊé¢„Åô
    const nextIdx = snap.findIndex((p, i) => !p.folded && !p.hasDrawn);
    if (nextIdx !== -1) {
      setTurn(nextIdx);
      runDrawRound({
        players: snap,
        turn: nextIdx,
        deck,
        setPlayers,
        setDeck,
         advanceAfterAction,
      });
   }
  }
}


function finishDrawRound() {
  const nextRound = drawRound + 1;
  if (nextRound > MAX_DRAWS) {
    debugLog("[DRAW] Max draws reached ‚Üí skipping");
    return;
  }

  setRaiseCountThisRound(0);

  const firstToAct =
    drawRound === 0
      ? (dealerIdx + 3) % NUM_PLAYERS // ÊúÄÂàù„Å†„ÅëUTG
      : (dealerIdx + 1) % NUM_PLAYERS; // ‰ª•Èôç„ÅØSB

  setDrawRound(nextRound); // ‚úÖ „Åì„Åì„Åß„ÅÆ„ÅøÈÄ≤Ë°å

  // BETÊ∫ñÂÇô
  const reset = players.map((p) => ({
    ...p,
    betThisRound: 0,
    lastAction: "",
    hasDrawn: false,
  }));
  setPlayers(reset);
  setCurrentBet(0);
  setBetHead(firstToAct);
  setTurn(firstToAct);
  setRaiseCountThisRound(0);
  setPhase("BET");

  debugLog(`[BET] === START BET #${nextRound} (after DRAW #${drawRound}) ===`);
  setTimeout(() => logState(`ENTER BET#${nextRound}`), 0);
}



  /* --- dealing --- */
  function dealNewHand(nextDealerIdx = 0) {
  debugLog(`[HAND] dealNewHand start ‚Üí dealer=${nextDealerIdx}`);
  const deckSrc = createDeck();
  const newDeck = shuffleDeck([...deckSrc]); // ‚Üê clone „Åó„Å¶Á¢∫ÂÆü„Å´Áã¨Á´ãÂèÇÁÖß„Å´

  // üß± Êó¢Â≠ò„Éó„É¨„Ç§„É§„Éº„Åã„Çâ„Çπ„Çø„ÉÉ„ÇØ„Å®ÂêçÂâç„ÇíÂºï„ÅçÁ∂ô„ÅêÔºàÂ∫ßÂ∏≠Âõ∫ÂÆöÔºâ
  const prev = players.length === NUM_PLAYERS ? players : makeEmptyPlayers();

  // üÜï ÂÆåÂÖ®Êñ∞Ë¶èÈÖçÂàó„ÇíÁîüÊàê
  const newPlayers = Array.from({ length: NUM_PLAYERS }, (_, i) => ({
    name: prev[i].name ?? `P${i + 1}`,
    stack: prev[i].stack ?? 1000,
    hand: newDeck.splice(0, 4),
    folded: false,
    allIn: false,
    betThisRound: 0,
    hasDrawn: false,
    lastDrawCount: 0,
    selected: [],
    showHand: false,
    isDealer: i === nextDealerIdx,
    lastAction: "",
  }));

  // SB/BB „ÅÆ„Éñ„É©„Ç§„É≥„ÉâÊîØÊâï„ÅÑ
  const sbIdx = (nextDealerIdx + 1) % NUM_PLAYERS;
  const bbIdx = (nextDealerIdx + 2) % NUM_PLAYERS;
  newPlayers[sbIdx].stack -= SB;
  newPlayers[sbIdx].betThisRound = SB;
  newPlayers[bbIdx].stack -= BB;
  newPlayers[bbIdx].betThisRound = BB;

  // --- Áä∂ÊÖãÊõ¥Êñ∞ ---
  setPlayers(newPlayers);
  setDeck([...newDeck]);
  setPots([{ amount: SB + BB, eligible: [...Array(NUM_PLAYERS).keys()] }]);
  setCurrentBet(BB);
  setDealerIdx(nextDealerIdx);
  setDrawRound(0);
  setPhase("BET");
  setTurn((nextDealerIdx + 3) % NUM_PLAYERS); // UTG
  setBetHead((nextDealerIdx + 3) % NUM_PLAYERS);
  setShowNextButton(false);
  setTransitioning(false);

  // Raise„Ç´„Ç¶„É≥„Çø„ÉªÂ≠¶Áøí„É≠„Ç∞ÂàùÊúüÂåñ
  setRaiseCountThisRound(0);
  setRaisePerRound([0, 0, 0, 0]);
  setRaisePerSeatRound(Array(NUM_PLAYERS).fill(0).map(() => [0, 0, 0, 0]));
  setActionLog([]);

  // Ê¨°„Éè„É≥„ÉâÊ∫ñÂÇô
  handSavedRef.current = false;
  handIdRef.current = `${nextDealerIdx}-${Date.now()}`;

  debugLog("[HAND] New players dealt:", newPlayers.map(p => p.name));
  debugLog(`[STATE] phase=BET, drawRound=0, turn=${(nextDealerIdx + 3) % NUM_PLAYERS}, currentBet=${BB}`);

  setTimeout(() => logState("NEW HAND"), 0);

  // üß© deck„ÅåÊ≠£„Åó„ÅèÊõ¥Êñ∞„Åï„Çå„ÅüÂæå„Å´NPC„Çø„Éº„É≥„Å™„Å©„ÅÆËá™ÂãïÂá¶ÁêÜ„ÅåËµ∞„Çã„Çà„ÅÜ„Å´Áü≠ÈÅÖÂª∂„ÇíÂÖ•„Çå„Çã
  setTimeout(() => {
    setPlayers([...newPlayers]);
    setDeck([...newDeck]);
  }, 10);
}


  useEffect(() => {
    dealNewHand(0);
  }, []);

  // ‚ñº Áä∂ÊÖãÂ§âÂåñ„ÇíÁõ£Ë¶ñ„Åó„Å¶„É≠„Ç∞Âá∫Âäõ
useEffect(() => {
  debugLog(
    `[STATE] phase=${phase}, drawRound=${drawRound}, turn=${turn}, currentBet=${currentBet}`
  );
}, [phase, drawRound, turn, currentBet]);


  /* --- common: after BET action (snapshot-based) --- */
    /* --- common: after BET action (snapshot-based) --- */
  function afterBetActionWithSnapshot(snap, actedIndex) {
    if (transitioning) {
      setPlayers(snap);
      return;
    }

    // --- „É≠„Ç∞Âá∫ÂäõÂº∑Âåñ ---
    const phaseLabel = `[${phase}] Round=${drawRound}`;
    debugLog(
      `${phaseLabel} acted=${snap[actedIndex]?.name}, turn=${actedIndex}, currentBet=${currentBet}`
    );
    snap.forEach((p, i) =>
      debugLog(
        `  P${i + 1}(${p.name}): bet=${p.betThisRound}, stack=${p.stack}, folded=${p.folded}, allIn=${p.allIn}`
      )
    );

    // ÈÄî‰∏≠„ÅßÂãùË≤†Ê±∫ÁùÄ„Å™„ÇâÁµÇ‰∫Ü
    if (checkIfOneLeftThenEnd(snap)) return;

    // ÁèæÂú®„ÅÆÊúÄÂ§ß„Éô„ÉÉ„Éà„ÇíÂèçÊò†
    const maxNow = maxBetThisRound(snap);
    if (currentBet !== maxNow) setCurrentBet(maxNow);

    // Ê¨°„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ
    const next = nextAliveFrom(snap, actedIndex);
    setPlayers(snap);
    if (next === null) return;

    // ------------------------
    // BET„Éï„Çß„Éº„Ç∫‰∏≠
    // ------------------------
    if (phase === "BET") {
      const active = snap.filter((p) => !p.folded);
      const everyoneMatched = active.every(
        (p) => p.allIn || p.betThisRound === maxNow
      );

      debugLog(
        `[BET] Check status: everyoneMatched=${everyoneMatched}, next=${next}, betHead=${betHead}`
      );

      if (everyoneMatched && next === betHead) {
        debugLog(`[BET] ‚úÖ Round complete! ‚Üí finishBetRoundFrom(drawRound=${drawRound})`);
        setTransitioning(true);
        setTimeout(() => {
          finishBetRoundFrom(snap);
          setTransitioning(false);
        }, 50); // ‚Üê Â∞ë„Åó„Éá„Ç£„É¨„Ç§„ÇíÂÖ•„Çå„Çã
        return;
      }

      setTurn(next);
      return;
    }

    // ------------------------
    // DRAW„Éï„Çß„Éº„Ç∫‰∏≠
    // ------------------------
    if (phase === "DRAW") {
      const allActiveDrawn = snap.every((p) => p.folded || p.hasDrawn);
      debugLog(`[DRAW] Check: allActiveDrawn=${allActiveDrawn}`);

      if (allActiveDrawn) {
        finishDrawRound();
        return;
      }

      const nextIdx = snap.findIndex(
        (p, i) => !p.folded && !p.hasDrawn && i !== 0
      );
      if (nextIdx !== -1) {
        setTurn(nextIdx);
        runDrawRound({
          players: snap,
          turn: nextIdx,
          deck,
          setPlayers,
          setDeck,
          advanceAfterAction,
        });
      }
    }
  }




  /* --- actions: BET --- */
  function playerFold() {
    if (phase !== "BET") return;
    const snap = [...players];
    const me = { ...snap[0] };
    me.folded = true;
    me.lastAction = "Fold";
    logAction(0, "Fold");
    snap[0] = me;
    recordActionToLog({
      round: currentBetRoundIndex(),
      seat: 0,
      type: me.lastAction,
      stackBefore: me.stack,
      betAfter: me.betThisRound,
      raiseCountTable: raiseCountThisRound,
    });

    afterBetActionWithSnapshot(snap, 0);
  }

  function playerCall() {
    if (phase !== "BET") return;
    const snap = [...players];
    const me = { ...snap[0] };
    const maxNow = maxBetThisRound(snap);
    const toCall = Math.max(0, maxNow - me.betThisRound);
    const pay = Math.min(me.stack, toCall);

    me.stack -= pay;
    me.betThisRound += pay;
    me.lastAction = toCall === 0 ? "Check" : pay < toCall ? "Call (All-in)" : "Call";
    logAction(0, me.lastAction, { toCall, pay, newBet: me.betThisRound });
    if (me.stack === 0) me.allIn = true;

    snap[0] = me;
    afterBetActionWithSnapshot(snap, 0);

    recordActionToLog({
      round: currentBetRoundIndex(),
      seat: 0,
      type: me.lastAction,
      stackBefore: me.stack + pay,
      betAfter: me.betThisRound,
      raiseCountTable: raiseCountThisRound,
    });

  }

  function playerCheck() {
    if (phase !== "BET") return;
    const snap = [...players];
    const me = { ...snap[0] };
    const maxNow = maxBetThisRound(snap);
    if (me.betThisRound === maxNow || me.allIn) {
      me.lastAction = "Check";
      logAction(0, "Check");
      snap[0] = me;
      recordActionToLog({
        round: currentBetRoundIndex(),
        seat: 0,
        type: me.lastAction,
        stackBefore: me.stack,
        betAfter: me.betThisRound,
        raiseCountTable: raiseCountThisRound,
      });

      afterBetActionWithSnapshot(snap, 0);
    } else {
      playerCall();
    }
  }

    // --- 5„Éô„ÉÉ„Éà„Ç≠„É£„ÉÉ„Éó‰ªò„Åç Raise Âá¶ÁêÜ ---
  function playerRaise() {
     if (phase !== "BET") return;
     const snap = [...players];
     const me = { ...snap[0] };

    // ‚úÖ 5bet„Ç≠„É£„ÉÉ„ÉóÂà§ÂÆöÔºàRaise‰∏äÈôê4ÂõûÔºâ
     if (raiseCountThisRound >= 4) {
       logAction(0, "Raise blocked (5-bet cap reached)", { raiseCountThisRound });
       debugLog(`[CAP] 5-bet cap reached (Raise blocked after ${raiseCountThisRound})`);
       playerCall(); // CallÊâ±„ÅÑ
       return;
     }

    // ÁèæÂú®„ÅÆÊúÄÂ§ß„Éô„ÉÉ„ÉàÈ°ç
    const maxNow = maxBetThisRound(snap);
    const toCall = Math.max(0, maxNow - me.betThisRound);
    const raiseAmt = betSize;
    const total = toCall + raiseAmt;

    // --- Raise ÂÆüË°å ---
    const pay = Math.min(me.stack, total);
    me.stack -= pay;
    me.betThisRound += pay;
    me.lastAction = pay < total ? "Raise (All-in)" : "Raise";
    
    if (me.stack === 0) me.allIn = true;

    snap[0] = me;

    // ‚úÖ RaiseÂõûÊï∞„Ç§„É≥„ÇØ„É™„É°„É≥„Éà
    setRaiseCountThisRound((c) => c + 1);

    // ‚úÖ ÊúÄÂæå„Å´Raise„Åó„Åü„Éó„É¨„Ç§„É§„Éº„Çí„Éô„ÉÉ„Éà„Éò„ÉÉ„Éâ„Å´Êõ¥Êñ∞
    setBetHead(0); // ‚Üê Ëá™ÂàÜ„ÅåRaise„Åó„Åü„ÅÆ„ÅßbetHead„ÇíÊõ¥Êñ∞

     logAction(0, me.lastAction, {
       toCall,
       raise: raiseAmt,
       pay,
       newBet: me.betThisRound,
       raiseCount: raiseCountThisRound + 1,
    });

    // „É¨„Ç§„Ç∫Âæå„ÅÆÊúÄÂ§ß„Éô„ÉÉ„ÉàÈ°ç„ÇíÊõ¥Êñ∞
    const newMax = maxBetThisRound(snap);
    if (currentBet !== newMax) setCurrentBet(newMax);

    afterBetActionWithSnapshot(snap, 0);

    // === „É≠„Ç∞ËøΩË®ò ===
    recordActionToLog({
      round: currentBetRoundIndex(),
      seat: 0,
      type: me.lastAction,
      stackBefore: me.stack + pay,
      betAfter: me.betThisRound,
      raiseCountTable: raiseCountThisRound + 1,
    });

  }


  /* --- actions: DRAW --- */
  function toggleSelectCard(cardIdx) {
    if (phase !== "DRAW" || turn !== 0) return;
    const newPlayers = players.map((p) => ({ ...p, hand: [...p.hand] }));
    const p = { ...newPlayers[0] };
    const sel = p.selected ?? [];
    p.selected = sel.includes(cardIdx) ? sel.filter((x) => x !== cardIdx) : [...sel, cardIdx];
    newPlayers[0] = p;
    setPlayers(newPlayers);
  }

  function drawSelected() {
    debugLog(`[CHECK] phase=${phase}, drawRound=${drawRound}, MAX_DRAWS=${MAX_DRAWS}`);
    if (phase !== "DRAW" || drawRound >= MAX_DRAWS) return;
    // üîß Deck„ÇÇplayers„ÇÇÂÆåÂÖ®deep„Ç≥„Éî„ÉºÔºàReact„ÅåÂ§âÊõ¥„ÇíÊ§úÁü•„Åß„Åç„Çã„Çà„ÅÜ„Å´Ôºâ
    const newDeck = [...deck];
    const newPlayers = players.map(p => ({ ...p, hand: [...p.hand] }));
    const p = { ...newPlayers[0], hand: [...newPlayers[0].hand] };
    const sel = p.selected || [];
    
    if (sel.length > 0) {
      // --- ‰∫§ÊèõÂâç„ÅÆÊâãÊú≠„Çí‰øùÊåÅ ---
      const oldHand = [...p.hand];
      const replaced = []; // [ { index, oldCard, newCard } ] „É≠„Ç∞Áî®
      const newHand = [...p.hand];
      sel.forEach((i) => {
        if (newDeck.length > 0) {
          const newCard = newDeck.pop();
          replaced.push({ index: i, oldCard: newHand[i], newCard }); // ‰∫§ÊèõÊÉÖÂ†±„Çí‰øùÂ≠ò
          newHand[i] = newCard;
        }
      });
      p.hand = newHand;
      // --- „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞Âá∫Âäõ ---
      console.log(`[DRAW] You exchanged ${sel.length} card(s):`);
      replaced.forEach(({ index, oldCard, newCard }) =>
        console.log(`   slot[${index}] ${oldCard} ‚Üí ${newCard}`)
    );

    // --- Â≠¶Áøí„É≠„Ç∞„Å´ËøΩÂä† ---
    recordActionToLog({
      round: currentBetRoundIndex(),
      seat: 0,
      type: `DRAW (${sel.length})`,
      stackBefore: p.stack,
      betAfter: p.betThisRound,
      raiseCountTable: raiseCountThisRound,
      drawInfo: {
        drawCount: sel.length,
        replacedCards: replaced,
        before: oldHand,
        after: p.hand,
      },
    });
  }

  p.selected = [];
  p.hasDrawn = true;
  p.lastDrawCount = sel.length;
  newPlayers[0] = p;

    // ‚úÖ Êñ∞„Åó„ÅÑÂèÇÁÖß„ÇíÊåÅ„Å£„Åüstate„ÇíÁ¢∫ÂÆü„Å´ÂèçÊò†„Åï„Åõ„Çã
   setDeck([...newDeck]);
  setPlayers([...newPlayers]);

  // advanceAfterAction „Å´ÊúÄÊñ∞ players „ÇíÊ∏°„Åô
  setTimeout(() => {
    advanceAfterAction(newPlayers);
  }, 100);
}

  /* --- NPC auto --- */
  useEffect(() => {
  if (!players || players.length === 0) return;
  if (turn === 0) return; // Ëá™ÂàÜ„ÅÆÁï™„ÅØUIÊìç‰Ωú

  const p = players[turn];
  if (!p || p.folded) {
    const nxt = nextAliveFrom(players, turn);
    if (nxt !== null) setTurn(nxt);
    return;
  }

  const timer = setTimeout(() => {
    if (phase === "BET") {
      const snap = [...players];
      const me = { ...snap[turn] };
      const maxNow = maxBetThisRound(snap);
      const toCall = Math.max(0, maxNow - me.betThisRound);
      const score = evaluateBadugi(me.hand).score;
      const r = Math.random();

      if (toCall > 0 && r < 0.15 && score > 5) {
        me.folded = true;
        me.lastAction = "Fold";
      } else {
        const pay = Math.min(me.stack, toCall);
        me.stack -= pay;
        me.betThisRound += pay;
        me.lastAction = toCall === 0 ? "Check" : "Call";
      }

      // „Åü„Åæ„Å´Raise
      if (!me.allIn && Math.random() > 0.9 && raiseCountThisRound < 4) {
        const add = Math.min(me.stack, betSize);
        me.stack -= add;
        me.betThisRound += add;
        me.lastAction = "Raise";
        setRaiseCountThisRound((c) => c + 1);
        setBetHead(turn);
      }

      snap[turn] = me;
      logAction(turn, me.lastAction);
      recordActionToLog({
        round: currentBetRoundIndex(),
        seat: turn,
        type: me.lastAction,
        stackBefore: me.stack,
        betAfter: me.betThisRound,
        raiseCountTable: raiseCountThisRound,
      });
      afterBetActionWithSnapshot(snap, turn);
      } else if (phase === "DRAW") {
    const snap = [...players];

    // 1) ÊúâÂäπ„Éó„É¨„Ç§„É§„ÉºÔºà„Éï„Ç©„Éº„É´„Éâ/„Ç™„Éº„É´„Ç§„É≥‰ª•Â§ñÔºâ
    const actives = snap.filter(p => !p.folded && !p.allIn);
    const everyoneDrawn = actives.every(p => p.hasDrawn);

    // 2) ÂÖ®Âì°„Éâ„É≠„ÉºÊ∏à„Åø„Å™„Çâ‰∏ÄÂõû„Å†„ÅëBET„Å∏ÈÅ∑Áßª
    if (everyoneDrawn) {
      if (!transitioning) {
        setTransitioning(true);
        setTimeout(() => {
          finishDrawRound();
          setTransitioning(false);
        }, 50);
      }
      return;
    }

    // 3) Ê¨°„Å´„Éâ„É≠„Éº„Åô„Åπ„Åç‰∫∫ÔºàhasDrawn=false „ÅÆÊúÄÂàù„ÅÆ‰∫∫Ôºâ„ÇíÂõ∫ÂÆö
    const nextToDraw = snap.findIndex(p => !p.folded && !p.allIn && !p.hasDrawn);
    if (nextToDraw === -1) {
      // Âøµ„ÅÆ„Åü„ÇÅ„ÅÆ‰øùÈô∫ÔºàÁêÜË´ñ‰∏ä„Åì„Åì„Å´„ÅØÊù•„Å™„ÅÑÔºâ
      if (!transitioning) {
        setTransitioning(true);
        setTimeout(() => {
          finishDrawRound();
          setTransitioning(false);
        }, 50);
      }
      return;
    }

    // 4) „Çø„Éº„É≥„Éù„Ç§„É≥„Çø„ÇíÊ¨°„Å´„Åô„Åπ„Åç‰∫∫„Å∏Âêà„Çè„Åõ„ÇãÔºà„Åê„Çã„Åê„ÇãÂõû„Åï„Å™„ÅÑÔºâ
    if (turn !== nextToDraw) {
      setTurn(nextToDraw);
      return;
    }

    // 5) ÂÆüÈöõ„ÅÆ„Éâ„É≠„ÉºÔºà‰ªä„ÅåÁï™„ÅÆ„Éó„É¨„Ç§„É§„Éº„Å†„ÅëÔºâ
    const me = { ...snap[nextToDraw] };
    const { score } = evaluateBadugi(me.hand);
    const drawCount = score > 8 ? 3 : score > 5 ? 2 : score > 3 ? 1 : 0;
    const newDeck = [...deck];
    const newHand = [...me.hand];
    for (let i = 0; i < drawCount; i++) {
      if (newDeck.length > 0) newHand[i] = newDeck.pop();
    }
    me.hand = newHand;
    me.hasDrawn = true;
    me.lastDrawCount = drawCount;
    me.lastAction = `DRAW(${drawCount})`;
    snap[nextToDraw] = me;

    setDeck(newDeck);
    setPlayers(snap);
    logAction(nextToDraw, me.lastAction);
    recordActionToLog({
      round: currentBetRoundIndex(),
      seat: nextToDraw,
      type: me.lastAction,
      stackBefore: me.stack,
      betAfter: me.betThisRound,
      raiseCountTable: raiseCountThisRound,
    });

    // 6) Ê¨°„ÅÆÊú™„Éâ„É≠„ÉºËÄÖ„Å∏„ÄÇ„ÅÑ„Å™„Åë„Çå„Å∞BET„Å∏
    const nextAfter = snap.findIndex(p => !p.folded && !p.allIn && !p.hasDrawn);
    if (nextAfter !== -1) {
      setTurn(nextAfter);
    } else {
      if (!transitioning) {
        setTransitioning(true);
        setTimeout(() => {
          finishDrawRound();
          setTransitioning(false);
        }, 50);
      }
    }
  }

  }, 250);

  return () => clearTimeout(timer);
}, [
  turn,
  phase,
  players,
  deck,
  currentBet,
  transitioning,
  raiseCountThisRound,
  dealerIdx,
  betSize,
  nextAliveFrom,
  evaluateBadugi,
  afterBetActionWithSnapshot,
  finishDrawRound,
  logAction,
  recordActionToLog,
]);


  /* --- SHOWDOWNÂÆå‰∫Ü ‚Üí Â±•Ê≠¥‰øùÂ≠òÔºà1„Éè„É≥„Éâ1ÂõûÔºâ --- */
  useEffect(() => {
    if (phase !== "SHOWDOWN") return;
    if (handSavedRef.current) return;

    trySaveHandOnce({ playersSnap: players, dealerIdx, pots });
  }, [phase, showNextButton]); // eslint-disable-line react-hooks/exhaustive-deps

  // ===== Â±•Ê≠¥‰øùÂ≠ò„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ =====
  function trySaveHandOnce({ playersSnap, dealerIdx, pots, potOverride }) {
    debugLog("[HISTORY] trySaveHandOnce called");
    try {
      const handId = handIdRef.current ?? `${dealerIdx}-${Date.now()}`;
      handIdRef.current = handId;

      // Á∑è„Éù„ÉÉ„ÉàÔºàsettled + ÁèæÂú®„ÅÆbetÔºâ„ÇíÂÆâÂÖ®„Å´Ë®àÁÆó
      const pot =
        typeof potOverride === "number"
          ? potOverride
          : Number(
           ((pots || []).reduce((s, p) => s + (p?.amount || 0), 0) || 0) +
           ((playersSnap || []).reduce((s, p) => s + (p?.betThisRound || 0), 0) || 0)
          ) || 0;

      // ÂãùËÄÖÊé®ÂÆöÔºàevaluateBadugi „ÅßÊúÄËâØ„Çπ„Ç≥„Ç¢„ÇíÊåÅ„Å§Èùû„Éï„Ç©„Éº„É´„Éâ„ÅÆÂêçÂâçÔºâ
      const active = (playersSnap || []).filter((p) => !p.folded);
      let bestScore = Infinity;
      let winners = [];
      active.forEach((p) => {
        const sc = evaluateBadugi(p.hand).score; // „ÅÇ„Å™„Åü„ÅÆË©ï‰æ°Èñ¢Êï∞„ÇíÂà©Áî®
        if (sc < bestScore) {
          bestScore = sc;
          winners = [p.name];
        } else if (sc === bestScore) {
          winners.push(p.name);
        }
      });

      const record = {
        handId,
        ts: Date.now(),
        tableSize: playersSnap.length,
        dealerIdx,
        players: playersSnap.map((p, i) => ({
          name: p.name ?? `P${i + 1}`,
          seat: i,
          stack: p.stack,
          folded: !!p.folded,
          // result „ÅØÈÖçÂàÜ„Åæ„ÅßËøΩ„ÅÑ„Å•„Çâ„ÅÑ„ÅÆ„Åß‰ªäÂõû„ÅØÁúÅÁï•ÔºàÂ∞ÜÊù•: runShowdown„Åã„ÇâÂèó„ÅëÂèñ„ÇãÔºâ
        })),
        actions: [], // ‰ªä„ÅØÊú™ÈõÜË®à„ÄÇÂ∞ÜÊù•: „Éô„ÉÉ„Éà/„Éâ„É≠„Éº„ÅÆ„É≠„Ç∞„ÇíË©∞„ÇÅ„Çã
        pot,
        winner: winners.length > 1 ? "split" : winners[0] ?? "-",
        raiseStats: {
          perRound: raisePerRound,                 // ‰æã: [2,0,3,1]
          perSeatPerRound: raisePerSeatRound,      // ‰æã: [[1,0,1,0],[1,0,2,1],...]
          totalRaises: raisePerRound.reduce((a,b)=>a+b,0),
          roundsPlayed: Math.max(
            1, // „Éó„É™„ÅØÂøÖ„Åö„ÅÇ„Çã
            Math.min(drawRound + 1, 4) // ÈÄ≤Ë°åÁä∂Ê≥Å„Å´Âøú„Åò„ÅüBETÊï∞
          ),
          lastRoundIndex: Math.min(drawRound, 3),  // 0..3
          actionLog: actionLog,
          },
      };

      saveRLHandHistory(record);
      console.log("[HISTORY] saveRLHandHistory() called successfully");
      debugLog("[HISTORY] saved:", record.handId, record.winner);
      handSavedRef.current = true;
      // console.debug("Hand saved:", record);
    } catch (e) {
      // ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Å¶„ÇÇ„Ç≤„Éº„É†„ÅØÁ∂ôÁ∂ö
      // console.error("save hand failed", e);
    }
  }

  /* --- UI --- */
  const centerX = typeof window !== "undefined" ? window.innerWidth / 2 : 400;
  const centerY = typeof window !== "undefined" ? window.innerHeight / 2 : 300;
  const radiusX = 350;
  const radiusY = 220;

  // üÉè ÊâãÊú≠„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ
function handleCardClick(i) {
  // „Éó„É¨„Ç§„É§„Éº„ÅÆÈÅ∏ÊäûÁä∂ÊÖã„Çí„Éà„Ç∞„É´
  setPlayers((prev) => {
    return prev.map((p, idx) => {
      if (idx !== 0) return p; // Ëá™ÂàÜ‰ª•Â§ñ„ÅØ„Åù„ÅÆ„Åæ„Åæ

      const selected = p.selected ? [...p.selected] : [];
      const already = selected.includes(i);
      const newSelected = already
        ? selected.filter((x) => x !== i)
        : [...selected, i];

      // „Åæ„Å£„Åü„ÅèÊñ∞„Åó„ÅÑ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíËøî„Åô
      return {
        ...p,
        selected: newSelected,
      };
    });
  });
}


  return (
  <div className="flex flex-col h-screen bg-gray-900 text-white">
    {/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ „Éò„ÉÉ„ÉÄ„ÉºÂõ∫ÂÆö ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */}
    <header className="flex justify-between items-center px-6 py-3 bg-gray-800 shadow-md fixed top-0 left-0 right-0 z-50">
      <h1 className="text-2xl font-bold text-white">Badugi App</h1>

      <nav className="flex gap-4">
        <button
          onClick={() => navigate("/home")}
          className="hover:text-yellow-400 transition"
        >
          Home
        </button>
        <button
          onClick={() => navigate("/profile")}
          className="hover:text-yellow-400 transition"
        >
          Profile
        </button>
        <button
          onClick={() => navigate("/history")}
          className="hover:text-yellow-400 transition"
        >
          History
        </button>
      </nav>
    </header>

    {/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ „É°„Ç§„É≥„ÉÜ„Éº„Éñ„É´È†òÂüü ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */}
    <main className="flex-1 mt-20 relative flex items-center justify-center overflow-auto bg-green-700">
      {/* „ÉÜ„Éº„Éñ„É´ÔºàÊó¢Â≠ò„Ç≤„Éº„É†ÈÉ®ÂàÜÔºâ */}
      <div className="relative w-[95%] max-w-[1200px] aspect-[4/3] bg-green-700 border-4 border-yellow-600 rounded-3xl shadow-inner">
        {/* Â∑¶‰∏äÔºöPot */}
        <div className="absolute top-4 left-4 text-white font-bold space-y-1">
          <div>Total Pot: {totalPotForDisplay}</div>
        </div>

        {/* Âè≥‰∏äÔºöPhase, Dealer „Å™„Å© */}
        <div className="absolute top-4 right-4 text-white font-bold text-right space-y-1">
          <div>Phase: {phaseTagLocal()}</div>
          <div>Draw Progress: {drawRound}/{MAX_DRAWS}</div>
          {phase === "BET" && (
            <div>Raise Count (Table): {raiseCountThisRound} / 4</div>
          )}
          <div>Dealer: {players[dealerIdx]?.name ?? "-"}</div>
        </div>

        {/* ‚ñº „Éó„É¨„Ç§„É§„ÉºÈÖçÁΩÆÈÉ®ÂàÜ */}
        {players.map((p, i) => (
          <Player
            key={i}
            player={p}
            index={i}
            selfIndex={0}
            phase={phase} 
            turn={turn}
            dealerIdx={dealerIdx}
            onCardClick={handleCardClick}
          />
        ))}
        {/* controlsÔºöBETÊôÇ or DRAWÊôÇ „ÅÑ„Åö„Çå„Åã‰∏ÄÊñπ„Å†„Åë */}
        {turn === 0 && players[0] && !players[0].folded && (
        <div className="absolute bottom-8 right-8 z-50 flex flex-col items-end space-y-2">
          {phase === "BET" && (
            <Controls
              phase="BET"
              currentBet={currentBet}
              player={players[0]}
              onFold={playerFold}
              onCall={playerCall}
              onCheck={playerCheck}
              onRaise={playerRaise}
            />
          )}
          {phase === "DRAW" && (
            <Controls
              phase="DRAW"
              player={players[0]}
              onDraw={drawSelected}
            />
          )}
        </div>
      )}

        {/* showdownÂæå„ÅÆ Next Hand */}
      {showNextButton && (
        <div className="absolute bottom-10 left-1/2 transform -translate-x-1/2 z-50">
          <button
            onClick={() => {
              if (!handSavedRef.current) {
                trySaveHandOnce({ playersSnap: players, dealerIdx, pots });
              }
              const nextDealer = (dealerIdx + 1) % NUM_PLAYERS;
              dealNewHand(nextDealer);
              setShowNextButton(false);
            }}
            className="px-6 py-3 bg-yellow-500 text-black font-bold rounded shadow-lg"
          >
            Next Hand
          </button>
        </div>
      )}

      {/* ‚ñº „Éá„Éê„ÉÉ„Ç∞„Éà„Ç∞„É´„Çπ„Ç§„ÉÉ„ÉÅ */}
      <div className="absolute bottom-4 left-4 z-50">
        <button
          onClick={() => setDebugMode((v) => !v)}
          className={`px-4 py-2 rounded font-bold ${
      debugMode ? "bg-red-500" : "bg-gray-600"
          }`}
        >
          {debugMode ? "DEBUG ON" : "DEBUG OFF"}
        </button>
      </div>
      </div>
    </main>
  </div>
);
}
